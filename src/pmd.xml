<?xml version="1.0"?>
<ruleset name="CS 1705 Rules"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="../etc/ruleset_xml_schema.xml">
  <description>
The CS 1705 Rules ruleset contains the full collection of checks we
expect all of our students to follow.  It contains a subset of the
checks in all of the sets predefined in PMD 3.2, together with a
couple of custom checks.
  </description>

<!--
  The checks in this file are organized according to the named
  rulesets in the PMD documentation.  Just go to the Rule Sets Index
  link in the PMD documentation to find the order used here.
  -->


<!-- ============================================================
     Finalizer Rules
     ============================================================ -->

    <rule name="EmptyFinalizer"
          message="Avoid empty finalize methods"
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       If the finalize() method is empty, then it does not need to exist.
       </description>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
   //MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
      /Block[count(*)=0]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
       <example>
<![CDATA[
   public class Foo {
       protected void finalize() {}
   }
]]>
       </example>
     </rule>

    <rule name="FinalizeOnlyCallsSuperFinalize"
          message="Finalize should do something besides just calling super.finalize()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/finalizers.html#FinalizeOnlyCallsSuperFinalize">
       <description>
If the finalize() is implemented, it should do something besides just calling
super.finalize().
       </description>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration[MethodDeclarator[@Image="finalize"][not(FormalParameters/*)]]
   /Block[count(BlockStatement)=1]
     /BlockStatement[
       Statement/StatementExpression/PrimaryExpression
      /PrimaryPrefix[@Image="finalize"]
      ]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
       <example>
           <![CDATA[
public class Foo {
   protected void finalize() {
     super.finalize();
   }
}
           ]]>
       </example>
     </rule>

<rule name="FinalizeOverloaded"
      message="Finalize methods should not be overloaded"
      class="net.sourceforge.pmd.rules.XPathRule">
   <description>
   Methods named finalize() should not have parameters.  It is
   confusing and probably a bug to overload finalize().  It will
   not be called by the VM.
   </description>
    <properties>
        <property name="xpath">
            <value>
<![CDATA[
//MethodDeclaration
 /MethodDeclarator[@Image='finalize'][FormalParameters[count(*)>0]]
]]>
            </value>
        </property>
    </properties>
    <priority>3</priority>
   <example>
<![CDATA[
   public class Foo {
       // this is confusing and probably a bug
       protected void finalize(int a) {
       }
   }
]]>
   </example>
 </rule>

    <rule name="FinalizeDoesNotCallSuperFinalize"
          message="Last statement in finalize method should be a call to super.finalize()"
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       If the finalize() is implemented, its last action should be to call super.finalize
       </description>
        <properties>
            <property name="xpath">
                <value>
<!-- in english: a method declaration of finalize(), with no arguments, containing
a block whose last statement is NOT a call to super.finalize -->
<![CDATA[
//MethodDeclaration[MethodDeclarator[@Image='finalize'][not(FormalParameters/*)]]
   /Block
      /BlockStatement[last()]
      [not(Statement/StatementExpression/PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
      [not(Statement/TryStatement/FinallyStatement
       /Block/BlockStatement/Statement/StatementExpression
        /PrimaryExpression/PrimaryPrefix[@Image='finalize'])]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
       <example>
<![CDATA[
public class Foo {
   protected void finalize() {
       something();
       // neglected to call super.finalize()
   }
}
]]>
       </example>
     </rule>

    <rule name="ExplicitCallToFinalize"
           message="Explicit call of finalize method"
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       An explicit call was made to a finalize method.  Finalize methods
       are meant to be executed at most once (by the garbage collector).
       Calling it explicitly could result in the method being executed
       twice for that object (once by you, once by the garbage collector).
       </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//PrimaryExpression[PrimarySuffix
 /Arguments[count(*) = 0]]
  /PrimaryPrefix
   /Name[@Image = 'finalize' or ends-with(@Image, '.finalize')]
]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>
       <example>
   <![CDATA[
public class Foo {
 public void close()  {
    finalize();       // this is bad
    foo.finalize();   // this is also bad
    this.finalize();  // this is bad but currently not flagged
    super.finalize(); // this is OK
    foo.finalize(3);  // this is arguably OK because the method is overloaded
 }
}
   ]]>
       </example>
     </rule>

    <rule name="FinalizeShouldBeProtected"
          message="If you override finalize(), make it protected"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      If you override finalize(), make it protected.  Otherwise, subclasses
          may not called your implementation of finalize.
      </description>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//MethodDeclaration[@Protected="false"]
  /MethodDeclarator[@Image="finalize"]
  [not(FormalParameters/*)]
                    ]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
 public void finalize() {
  // do something
 }
}
  ]]>
      </example>
    </rule>


<!-- ============================================================
     Unused Code Rules
     ============================================================ -->

  <rule name="UnusedPrivateField"
        message="The private field ''{0}'' is declared, but is not used by the class."
        class="net.sourceforge.pmd.rules.UnusedPrivateFieldRule">
    <description>
Detects when a private field is declared and/or assigned a value, but not used.
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class Something {
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne() {
    return j++;
  }
}
]]>
    </example>
  </rule>

<rule name="UnusedLocalVariable"
        message="The local variable ''{0}'' is declared, but is not used (except possibly for initial assignment)."
        class="net.sourceforge.pmd.rules.UnusedLocalVariableRule">
    <description>
Detects when a local variable is declared and/or assigned, but not used.
    </description>
    <priority>3</priority>

    <example>
<![CDATA[
public void doSomething() {
  int i = 5; // Unused
}
]]>
    </example>
  </rule>



    <rule name="UnusedPrivateMethod"
        message="The private method ''{0}'' is declared, but is not used by the class."
        class="net.sourceforge.pmd.rules.UnusedPrivateMethodRule">
    <description>
Unused Private Method detects when a private method is declared but is unused.
    </description>
        <priority>3</priority>
    <example>
<![CDATA[
public class Something {
 private void foo() {} // unused
}
]]>
    </example>
  </rule>


  <rule name="UnusedFormalParameter"
        message="The formal parameter ''{0}'' is declared, but is not used by the method."
        class="net.sourceforge.pmd.rules.UnusedFormalParameterRule">
    <description>
Avoid passing parameters to methods and then not using those parameters.
    </description>
      <priority>3</priority>

    <example>
<![CDATA[
public class Foo {
 private void bar(String howdy) {
  // howdy is not used
 }
]]>
    </example>
  </rule>


<!-- ============================================================
     Controversial Rules
     ============================================================ -->

    <rule name="SuspiciousOctalEscape"
       message="Suspicious decimal characters following octal escape in string literal"
          class="net.sourceforge.pmd.rules.SuspiciousOctalEscape">
      <description>
      A suspicious octal escape sequence was found inside a String literal.
      The Java language specification (section 3.10.6) says an octal
      escape sequence inside a literal String shall consist of a backslash
      followed by:

           OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit

      Any octal escape sequence followed by non-octal digits can be confusing,
      e.g. "\038" is interpreted as the octal escape sequence "\03" followed by
      the literal character "8".
      </description>
      <priority>3</priority>
      <example>
<![CDATA[
 public class Foo {
    public void foo() {
       // interpreted as octal 12, followed by character '8'
       System.out.println("suspicious: \128");
    }
 }
]]>
      </example>
    </rule>

    <rule name="UnnecessaryParentheses"
          message="This return statement may have some unnecessary parentheses"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Sometimes return statement expressions are wrapped in unnecessary parentheses,
 making them look like a function call.
      </description>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//ReturnStatement
          /Expression
           /PrimaryExpression
            /PrimaryPrefix
             /Expression[count(*)=1]
              /PrimaryExpression
              /PrimaryPrefix]]>
            </value>
        </property>
    </properties>
        <priority>3</priority>
      <example>
  <![CDATA[public class Foo {
      boolean bar() {
          return (true);
      }
  }]]>
      </example>
    </rule>


<!-- ============================================================
     Coupling Rules
     ============================================================ -->


<!-- ============================================================
     Optimization Rules
     ============================================================ -->


<!-- ============================================================
     Basic Rules
     ============================================================ -->

    <rule name="EmptyIfStmt"
          message="An empty 'if' statement checks a condition but does nothing about it.  Usually, code still needs to be added to the statement, or the entire statement should be removed."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Empty If Statement finds instances where a condition is checked but nothing is done about it.
    </description>
        <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[//IfStatement/Statement/Block[count(*) = 0]]]>
              </value>
          </property>
      </properties>
      <example>
    <![CDATA[if (foo == 0) {
       // why bother checking up on foo?
    }]]>
       </example>
    </rule>


    <rule name="EmptyWhileStmt"
          message="An empty 'while' statement does nothing.  If it is a timing loop, then you should use 'Thread.sleep()' for it; if it is a 'while' loop that does a lot in its conditional expression, rewrite it to make it clearer."
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
  Empty While Statement finds all instances where a while statement
  does nothing.  If it is a timing loop, then you should use Thread.sleep() for it; if
  it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
       </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
                  //WhileStatement/Statement[./Block[count(*) = 0]  or ./EmptyStatement]
                  ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

       <example>
  <![CDATA[while (a == b) {
    // not good
  }]]>
       </example>
    </rule>


    <rule name="EmptyTryBlock"
          message="Avoid empty 'try' blocks."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid empty try blocks - what's the point?
      </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[//TryStatement/Block[1][count(*) = 0]]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[// this is bad
  public void bar() {
      try {
      } catch (Exception e) {
          e.printStackTrace();
      }
  }]]>
      </example>
    </rule>

    <rule name="EmptyFinallyBlock"
          message="Avoid empty 'finally' blocks.  They can be deleted."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid empty finally blocks - these can be deleted.
      </description>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//FinallyStatement[count(Block/BlockStatement) = 0]
 ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[// this is bad
  public void bar() {
      try {
          int x=2;
      } finally {
      }
  }]]>
      </example>
    </rule>


    <rule name="EmptySwitchStatements"
          message="Avoid empty 'switch' statements."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Avoid empty switch statements.
      </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[//SwitchStatement[count(*) = 1]]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[public class Foo {
   public void bar() {
    int x = 2;
    switch (x) {
     // once there was code here
     // but it's been commented out or something
    }
   }
  }]]>
      </example>
      </rule>


    <rule name="JumbledIncrementer"
         message="Avoid using an outer loop's index variable in an inner loop's update expression.  It is usually a mistake, and it is confusing even if it is what was intended."
         class="net.sourceforge.pmd.rules.XPathRule">
     <description>
     Avoid jumbled loop incrementers - it's usually a mistake, and it's confusing even if it's what's intended.
     </description>
     <properties>
         <property name="xpath">
             <value>
 <![CDATA[//ForStatement
 [
  ForUpdate/StatementExpressionList/StatementExpression/PostfixExpression/PrimaryExpression/PrimaryPrefix/Name/@Image
  =
  ancestor::ForStatement/ForInit//VariableDeclaratorId/@Image
 ]]]>
             </value>
         </property>
     </properties>
        <priority>3</priority>

     <example>
 <![CDATA[public class JumbledIncrementerRule1 {
  public void foo() {
   for (int i = 0; i < 10; i++) {
    for (int k = 0; k < 20; i++) {
     System.out.println("Hello");
    }
   }
  }
 }]]>
     </example>
     </rule>


    <rule name="ForLoopShouldBeWhileLoop"
          message="This 'for' loop could be simplified to a 'while' loop to increase conciseness and readability."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Some for loops can be simplified to while loops - this makes them more concise.
      </description>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
 //ForStatement
  [count(*) > 1]
  [not(ForInit)]
  [not(ForUpdate)]
  [not(Type and Expression and Statement)]
 ]]>
            </value>
        </property>
    </properties>
        <priority>3</priority>
      <example>
  <![CDATA[public class Foo {
      void bar() {
          for (;true;) true; // No Init or Update part, may as well be: while (true)
      }
  }]]>
      </example>
    </rule>


    <rule name="UnnecessaryConversionTemporary"
          message="Avoid unnecessary temporaries when converting primitives to 'String's.  The static 'toString()' method on the wrapper class allows the 'new' to be removed."
          class="net.sourceforge.pmd.rules.UnnecessaryConversionTemporary">
      <description>
      Avoid unnecessary temporaries when converting primitives to Strings
      </description>
        <priority>3</priority>
      <example>
  <![CDATA[public String convert(int x) {
      // this wastes an object
      String foo = new Integer(x).toString();
      // this is better
      return Integer.toString(x);
    }]]>
      </example>
    </rule>

    <rule name="DoubleCheckedLocking"
          message="Double checked locking is not thread safe in Java."
          class="net.sourceforge.pmd.rules.DoubleCheckedLocking">
      <description>
      Partially created objects can be returned by the Double Checked Locking pattern when used in Java.
      An optimizing JRE may assign a reference to the baz variable before it creates the object the
          reference is intended to point to.  For more details see http://www.javaworld.com/javaworld/jw-02-2001/jw-0209-double.html.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[public class Foo {
      Object baz;
      Object bar() {
        if(baz == null) { //baz may be non-null yet not fully created
          synchronized(this){
            if(baz == null){
              baz = new Object();
            }
          }
        }
        return baz;
      }
  }]]>
      </example>
    </rule>

    <rule name="ReturnFromFinallyBlock"
          message="Avoid returning from a finally block"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid returning from a finally block - this can discard exceptions.
      </description>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
 //FinallyStatement//ReturnStatement
 ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[public class Bar {
 public String bugga() {
  try {
   throw new Exception( "My Exception" );
  } catch (Exception e) {
   throw e;
  } finally {
   return "A. O. K."; // Very bad.
  }
 }
}]]>
      </example>
    </rule>

    <rule name="EmptySynchronizedBlock"
          message="Avoid empty synchronized blocks"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid empty synchronized blocks - they're useless.
      </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[//SynchronizedStatement/Block[1][count(*) = 0]]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[// this is bad
  public void bar() {
      synchronized (this) {}
  }]]>
      </example>
    </rule>

    <rule name="UnnecessaryReturn"
          message="Avoid unnecessary return statements"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/basic.html#UnnecessaryReturn">
      <description>
Avoid unnecessary return statements
      </description>
      <properties>
          <property name="xpath">
              <value>
 <![CDATA[
//ReturnStatement
 [parent::Statement
  [parent::BlockStatement
   [parent::Block
    [parent::MethodDeclaration/ResultType[@Void='true']
    ]
   ]
  ]
 ]
]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>
      <example>
  <![CDATA[
public class Foo {
 public void bar() {
  int x = 42;
  return;
 }
}
 ]]>
      </example>
    </rule>


    <rule name="EmptyStaticInitializer"
           message="Empty static initializer was found"
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       An empty static initializer was found.
       </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[//ClassOrInterfaceBodyDeclaration/Initializer[@Static='true']/Block[count(*)=0]]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>
       <example>
   <![CDATA[public class Foo {
  // why are there no statements in this static block?
  static {}
 }]]>
       </example>
     </rule>

    <rule name="UnconditionalIfStatement"
       message="Do not use 'if' statements that are always true or always false"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Do not use "if" statements that are always true or always false.
      </description>
        <properties>
            <property name="xpath">
                <value>
 <![CDATA[//IfStatement/Expression
 [count(PrimaryExpression)=1]
 /PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
      <example>
  <![CDATA[public class Foo {
 public void close() {
  if (true) {
       // ...
   }
 }
}]]>
      </example>
    </rule>

    <rule name="BooleanInstantiation"
       message="Avoid instantiating Boolean objects; you can usually invoke Boolean.TRUE instead."
       class="net.sourceforge.pmd.rules.XPathRule">
   <description>
   Avoid instantiating Boolean objects, instead use Boolean.TRUE or Boolean.FALSE.
   </description>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//PrimaryExpression
[
PrimaryPrefix/AllocationExpression[not (ArrayDimsAndInits) and (ClassOrInterfaceType/@Image='Boolean' or ClassOrInterfaceType/@Image='java.lang.Boolean')]
or
(
PrimaryPrefix/Name[@Image='Boolean.valueOf']
and
PrimarySuffix/Arguments//BooleanLiteral
)
]
]]>
              </value>
          </property>
      </properties>
      <priority>2</priority>
   <example>
   <![CDATA[
public class Foo {
 private Boolean bar = new Boolean("true"); // just do a Boolean bar = Boolean.TRUE;
}
   ]]>
   </example>
   </rule>

    <rule name="CollapsibleIfStatements"
          message="These nested if statements could be combined"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
      </description>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//IfStatement[@Else='false']/Statement
 /IfStatement[@Else='false']
 |
//IfStatement[@Else='false']/Statement
 /Block[count(BlockStatement)=1]/BlockStatement
  /Statement/IfStatement[@Else='false']]]>
            </value>
        </property>
    </properties>
        <priority>3</priority>
      <example>
  <![CDATA[public class Foo {
      void bar() {
          if (x) {
           if (y) {
             // do stuff
           }
          }
      }
  }]]>
      </example>
    </rule>


<!-- ============================================================
     Design Rules
     ============================================================ -->

  <rule name="SimplifyBooleanReturns"
        message="Avoid unnecessary if..then..else statements when returning a boolean"
        class="net.sourceforge.pmd.rules.SimplifyBooleanReturns">
    <description>
Avoid unnecessary if..then..else statements when returning a boolean
    </description>
      <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
  private int bar =2;
  public boolean isBarEqualsTo(int x) {
    // this bit of code
    if (bar == x) {
     return true;
    } else {
     return false;
    }
    // can be replaced with a simple
    // return bar == x;
  }
}
]]>
    </example>
  </rule>

    <rule name="SimplifyBooleanExpressions"
          message="Avoid unnecessary comparisons in boolean expressions"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid unnecessary comparisons in boolean expressions - this makes simple code seem complicated.
      </description>
      <properties>
          <property name="xpath">
              <value>
<![CDATA[
//EqualityExpression/PrimaryExpression/PrimaryPrefix/Literal/BooleanLiteral
]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Bar {
 // can be simplified to
 // bar = isFoo();
 private boolean bar = (isFoo() == true);

 public isFoo() { return false;}
}
  ]]>
      </example>
    </rule>


  <rule name="SwitchStmtsShouldHaveDefault"
        message="A 'switch' statement should have a default case."
        class="net.sourceforge.pmd.rules.XPathRule">
    <description>
    Switch statements should have a default label.
    </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
    //SwitchStatement[not(SwitchLabel[count(*) = 0])]
                  ]]>
              </value>
          </property>
      </properties>
      <priority>3</priority>

    <example>
<![CDATA[
public class Foo {
 public void bar() {
  int x = 2;
  switch (x) {
   case 2: int j = 8;
  }
 }
}
]]>
    </example>
    </rule>

    <rule name="AvoidReassigningParameters"
        message="Avoid reassigning parameters such as ''{0}''  Reassigning values to parameters is a questionable practice, and can mislead someone reading the code.  Use a temporary local variable instead."
        class="net.sourceforge.pmd.rules.AvoidReassigningParameters">
    <description>
Reassigning values to parameters is a questionable practice.  Use a temporary local variable instead.
    </description>
        <priority>2</priority>
    <example>
<![CDATA[
public class Foo {
 private void foo(String bar) {
  bar = "something else";
 }
}
]]>
    </example>
  </rule>

    <rule name="SwitchDensity"
          message="A high ratio of statements to labels in a 'switch' statement implies that the 'switch' statement is doing too much work.  Consider moving the statements either into new methods, or creating subclasses based on the 'switch' variable."
          class="net.sourceforge.pmd.rules.design.SwitchDensityRule">
      <description>
 A high ratio of statements to labels in a switch statement implies that the switch
 statement is doing too much work.  Consider moving the statements either into new
 methods, or creating subclasses based on the switch variable.
      </description>
        <priority>3</priority>
        <properties>
         <property name="minimum" value="10"/>
        </properties>
      <example>
 <![CDATA[
   public class Foo {
     private int x;
     public void bar() {
       switch (x) {
         case 1: {
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           System.out.println("I am a fish.");
           break;
         }

         case 2: {
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           System.out.println("I am a cow.");
           break;
         }
       }
     }
   }
 ]]>
      </example>
    </rule>

    <rule name="ConstructorCallsOverridableMethod"
          message="Calling overridable methods during construction poses a risk of invoking methods on an incompletely constructed object.  This situation can be difficult to discern.  It may leave the subclass unable to construct its superclass or forced to replicate the construction process completely within itself, losing the ability to call 'super()'.  If the default constructor contains a call to an overridable method, the subclass may be completely uninstantiable."
          class="net.sourceforge.pmd.rules.ConstructorCallsOverridableMethod">
      <description>
      Calling overridable methods during construction poses a risk of invoking methods on an
          incompletely constructed object.  This situation can be difficult to discern.
      It may leave the sub-class unable to construct its superclass or forced to
          replicate the construction process completely within itself, losing the ability to call
      super().  If the default constructor contains a call to an overridable method,
          the subclass may be completely uninstantiable.   Note that this includes method calls
          throughout the control flow graph - i.e., if a constructor Foo() calls a private method
            bar() that calls a public method buz(), there's a problem.
      </description>
        <priority>1</priority>
      <example>
  <![CDATA[
    public class SeniorClass {
      public SeniorClass(){
          toString(); //may throw NullPointerException if overridden
      }
      public String toString(){
        return "IAmSeniorClass";
      }
    }
    public class JuniorClass extends SeniorClass {
      private String name;
      public JuniorClass(){
        super(); //Automatic call leads to NullPointerException
        name = "JuniorClass";
      }
      public String toString(){
        return name.toUpperCase();
      }
    }
  ]]>
      </example>
    </rule>

    <rule name="AccessorClassGeneration"
          message="Avoid instantiation through private constructors from outside of the constructor's class."
          class="net.sourceforge.pmd.rules.AccessorClassGeneration">
      <description>
      Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessor.
      A factory method, or non-privitization of the constructor can eliminate this situation.
      The generated class file is actually an interface.  It gives the accessing class the ability to invoke a new hidden package
      scope constructor that takes the interface as a supplementary parameter.  This turns a private constructor effectively into
      one with package scope, though not visible to the naked eye.
      </description>
      <priority>3</priority>
      <example>
  <![CDATA[
  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//Causes generation of accessor
    }
    public class InnerClass {
      private InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = new InnerClass();//OK, due to public constructor
    }
    public class InnerClass {
      public InnerClass(){
      }
    }
  }

  public class OuterClass {
    void method(){
      InnerClass ic = InnerClass.getInnerClass();//OK
    }
    public static class InnerClass {
      private InnerClass(){
      }
      private static InnerClass getInnerClass(){
        return new InnerClass();
      }
    }
  }

  public class OuterClass {
    private OuterClass(){
    }
    public class InnerClass {
      void method(){
        OuterClass oc = new OuterClass();//Causes generation of accessor
      }
    }
  }
  ]]>
      </example>
    </rule>

    <rule name="FinalFieldCouldBeStatic"
          message="This final field could be made static"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      If a final field is assigned to a compile-time constant, it could be
          made static, thus saving overhead in each object
      </description>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//FieldDeclaration
 [@Final='true' and @Static='false']
 [not (../../../../ClassOrInterfaceDeclaration[@Interface='true'])]
   /VariableDeclarator/VariableInitializer/Expression
    /PrimaryExpression/PrimaryPrefix/Literal
                    ]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Foo {
 public final int BAR = 42; // this could be static and save some space
}
  ]]>
      </example>
    </rule>


    <rule name="NonStaticInitializer"
           message="Non-static initializers are confusing"
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       A nonstatic initializer block will be called any time a constructor
       is invoked (just prior to invoking the constructor).  While this
       is a valid language construct, it is rarely used and is confusing.
       </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//ClassOrInterfaceBodyDeclaration/Initializer[@Static='false']
]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>
       <example>
   <![CDATA[
public class MyClass {
 // this block gets run before any call to a constructor
 {
  System.out.println("I am about to construct myself");
 }
}
   ]]>
       </example>
     </rule>

    <rule name="DefaultLabelNotLastInSwitchStmt"
           message="The default label should be the last label in a switch statement"
           class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#DefaultLabelNotLastInSwitchStmt">
       <description>
By convention, the default label should be the last label in a switch statement.
       </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//SwitchStatement
 [not(SwitchLabel[position() = last()][@Default='true'])]
 [SwitchLabel[@Default='true']]
]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>
       <example>
   <![CDATA[
public class Foo {
 void bar(int a) {
  switch (a) {
   case 1:  // do something
      break;
   default:  // the default case should be last, by convention
      break;
   case 2:
      break;
  }
 }
}   ]]>
       </example>
     </rule>

    <rule name="NonCaseLabelInSwitchStatement"
           message="A non-case label was present in a switch statement"
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       A non-case label (e.g. a named break/continue label) was present in a switch statement.
       This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
       </description>
         <properties>
             <property name="xpath">
                 <value>
 <![CDATA[
    //SwitchStatement//BlockStatement/Statement/LabeledStatement
 ]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>
       <example>
   <![CDATA[
public class Foo {
 void bar(int a) {
  switch (a)
  {
   case 1:
      // do something
      break;
   mylabel: // this is legal, but confusing!
      break;
   default:
      break;
  }
 }
}
   ]]>
       </example>
     </rule>

    <rule name="BadComparison"
          message="Avoid equality comparisons with Double.NaN; these are
likely to be logic errors."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  Avoid equality comparisons with Double.NaN - these are
likely to be logic errors.
      </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//EqualityExpression[@Image='==']
 /PrimaryExpression/PrimaryPrefix
 /Name[@Image='Double.NaN' or @Image='Float.NaN']
                  ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
  <![CDATA[
public class Bar {
int x = (y == Double.NaN);
}
  ]]>
      </example>
    </rule>

    <rule   name="EqualsNull"
            message="Don't use equals() to compare against null"
            class="net.sourceforge.pmd.rules.XPathRule">
        <description>
         Newbie programmers sometimes get the comparison concepts confused
         and use equals() to compare to null.
        </description>
        <properties>
            <property name="xpath">
                <value>
    <![CDATA[
    //PrimaryExpression
     [PrimaryPrefix/Name[ends-with(@Image, 'equals')]]
     [PrimarySuffix/Arguments/ArgumentList
      /Expression/PrimaryExpression/PrimaryPrefix
       /Literal/NullLiteral]
    ]]>
                </value>
            </property>
         </properties>
        <priority>1</priority>
    <example>
       <![CDATA[
    class Bar {
       void foo() {
           String x = "foo";
           if (x.equals(null)) { // bad!
            doSomething();
           }
       }
    }
    ]]>
        </example>
        </rule>

      <rule name="ConfusingTernary"
        message="Avoid if (x != y) ..; else ..;"
        class="net.sourceforge.pmd.rules.design.ConfusingTernary">
        <description>
          In an "if" expression with an "else" clause, avoid negation in
          the test.  For example, rephrase:
            if (x != y) diff(); else same();
          as:
            if (x == y) same(); else diff();
          Most "if (x != y)" cases without an "else" are often return
          cases, so consistent use of this rule makes the code easier
          to read.  Also, this resolves trivial ordering problems, such
          as "does the error case go first?" or "does the common case
          go first?".
        </description>
        <priority>3</priority>
        <example>
          <![CDATA[
          return (x != y) ? diff : same;
          ]]>
        </example>
      </rule>

    <rule name="InstantiationToGetClass"
          message="Avoid instantiating an object just to call getClass() on it; use the .class public member instead"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
Avoid instantiating an object just to call getClass() on it; use the .class public member instead
      </description>
        <example>
    <![CDATA[
class Foo {
 Class c = new String().getClass();
}
    ]]>
        </example>
        <priority>4</priority>
        <properties>
          <property name="xpath">
            <value>
                <![CDATA[
//PrimarySuffix
 [@Image='getClass']
 [parent::PrimaryExpression
  [PrimaryPrefix/AllocationExpression]
  [count(PrimarySuffix) = 2]
 ]
     ]]>
            </value>
          </property>
        </properties>
      </rule>

    <rule name="IdempotentOperations"
          message="Avoid idempotent operations (like assigning a variable to itself)"
          class="net.sourceforge.pmd.rules.IdempotentOperations">
      <description>
      Avoid idempotent operations - they are silly.
      </description>
        <priority>3</priority>

      <example>
      <![CDATA[
    public class Foo {
     public void bar() {
      int x = 2;
      x = x;
     }
    }
      ]]>
      </example>
    </rule>

    <rule name="AvoidProtectedFieldInFinalClass"
             message="Avoid protected fields in a final class.  Change to private or package access."
             class="net.sourceforge.pmd.rules.XPathRule">
         <description>
     Do not use protected fields in final classes since they cannot be subclassed.
    Clarify your intent by using private or package access modifiers instead.
         </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Final='true']//FieldDeclaration[@Protected='true'] 
 ]]>
                 </value>
             </property>
         </properties>
           <priority>3</priority>

         <example>
     <![CDATA[public final class Bar {
      private int x;
      protected int y;  // <-- Bar cannot be subclassed, so is y really private or package visible???
      Bar() {}
   }]]>
         </example>
       </rule>
       
    <rule name="AvoidCallingFinalize"
          message="Avoid calling finalize() explicitly"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
  finalize() is called by the garbage collector on an object when garbage collection determines
  that there are no more references to the object.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//Statement/StatementExpression/PrimaryExpression/PrimaryPrefix
[
./Name[
	@Image='finalize'
	or ends-with(@Image,'.finalize')
	]
or @Image='finalize'
]

    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[

	void foo() {
	    Bar b = new Bar();
	    b.finalize();
	}

]]>
      </example>
    </rule>


    <rule name="AvoidInstanceofChecksInCatchClause"
          message="An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type."
          class="net.sourceforge.pmd.rules.XPathRule">
    <description>
  Each caught exception type should be handled in its own catch clause.
      </description>
      <properties>
          <property name="xpath">
              <value>
    <![CDATA[
//CatchStatement/FormalParameter
 /following-sibling::Block//InstanceOfExpression/PrimaryExpression/PrimaryPrefix
  /Name[
   @Image = ./ancestor::Block/preceding-sibling::FormalParameter
    /VariableDeclaratorId/@Image
  ]
    ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>
      <example>
<![CDATA[
    // Avoid this
      try {
            ...something...
      }
      catch (Exception ee) {
            if (ee instanceof IOException) {
                cleanup();
            }
      }

      // Prefer this:
      try {
          ...something...
      }
      catch (IOException ee) {
            cleanup();
      }
]]>
      </example>
    </rule>

    <rule name="AbstractClassWithoutAbstractMethod"
          message="This abstract class does not have any abstract methods"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      The abstract class does not contain any abstract methods. An abstract class suggests
      an incomplete implementation, which is to be completed by subclasses implementing the
      abstract methods. If the class is intended to be used as a base class only (not to be instantiated
      direcly) a protected constructor can be provided prevent direct instantiation.
      </description>
      <properties>
          <property name="xpath">
              <value><![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true'
  and count( .//MethodDeclaration[@Abstract='true'] )=0 ]
  [count(ImplementsList)=0]
              ]]>
              </value>
          </property>
      </properties>
        <priority>3</priority>

      <example>
<![CDATA[
public abstract class Foo {
	void int method1() { ... }
	void int method2() { ... }
	// consider using abstract methods or removing
	// the abstract modifier and adding protected constructors
}
]]>
      </example>
    </rule>

    <rule name="SimplifyConditional"
              message="No need to check for null before an instanceof"
              class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/design.html#SimplifyConditional">
           <description>
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
           </description>
          <properties>
              <property name="xpath">
                  <value>
                      <![CDATA[
//Expression
 [ConditionalOrExpression
 [EqualityExpression[@Image='==']
  //NullLiteral
  and
  UnaryExpressionNotPlusMinus
   [@Image='!']//InstanceOfExpression[PrimaryExpression
     //Name/@Image = ancestor::ConditionalOrExpression/EqualityExpression
      //PrimaryPrefix/Name/@Image]]
or
ConditionalAndExpression
 [EqualityExpression[@Image='!=']//NullLiteral
 and
InstanceOfExpression
 [PrimaryExpression[count(PrimarySuffix[@ArrayDereference='true'])=0]
  //Name/@Image = ancestor::ConditionalAndExpression
   /EqualityExpression//PrimaryPrefix/Name/@Image]]]
 ]]>
                  </value>
              </property>
          </properties>
            <priority>3</priority>
           <example>
      <![CDATA[
class Foo {
 void bar(Object x) {
  if (x != null && x instanceof Bar) {
   // just drop the "x != null" check
  }
 }
}      ]]>
           </example>
        </rule>


<!-- ============================================================
     Security Code Guidelines
     ============================================================ -->


<!-- ============================================================
     Strict Exception Rules
     ============================================================ -->

   <rule name="AvoidCatchingThrowable"
         message="A catch statement should never catch throwable since it includes errors"
          class="net.sourceforge.pmd.rules.strictexception.AvoidCatchingThrowable">
      <description>
This is dangerous because if a java.lang.Error, for example OutOfMemmoryError,
occurs then it will be caught. The container should handle java.lang.Error.
If application code will catch them, try to log them (which will probably fail)
and continue silently the situation will not be desirable.
      </description>
      <priority>3</priority>
      <example>
                <![CDATA[
SimpleDateFormat sdf = null;
try {
    sdf = new SimpleDateFormat("yyyy-MM-dd");
} catch (Throwable th) {  //Should not catch throwable
    th.printStackTrace();
}
                ]]>
      </example>
    </rule>

<rule name="AvoidCatchingNPE"
    message="Avoid catching NullPointerException; remove the cause of the NPE instead."
    class="net.sourceforge.pmd.rules.XPathRule">
    <description>
      Code should never throw NPE under normal circumstances.  A catch block may hide the original error, causing other more subtle errors in its wake.
    </description>
    <example>  <![CDATA[
try {
  ...
} catch (NullPointerException npe) {
  ...
}
]]>
         </example>
    <priority> 3 </priority>
    <properties>
      <property name="xpath">
        <value>
            <![CDATA[
//CatchStatement/FormalParameter/Type
 /ReferenceType/ClassOrInterfaceType[@Image='NullPointerException']
 ]]>
        </value>
      </property>
    </properties>
  </rule>

    <rule name="AvoidThrowingNullPointerException"
        message="Avoid throwing null pointer exceptions; this is confusing to others, since the assumption is that the VM threw NPE due to faulty code.  If you are reporting an invalid argument, use 'IllegalArgumentException' instead."
        class="net.sourceforge.pmd.rules.XPathRule">
      <description>
Avoid throwing a NullPointerException - it's confusing because most people will assume that the
   VM threw NPE.  Consider using InvalidArgumentException("Null parameter") which will be clearly seen as
  a programmer initiated exception..  Use IllegalArgumentException or IllegalStateException instead.
      </description>
   <example>
        <![CDATA[
  throw new NullPointerException();
  ]]>
      </example>
      <priority> 1 </priority>
      <properties>
        <property name="xpath">
          <value>
              <![CDATA[
  //AllocationExpression/ClassOrInterfaceType[@Image='NullPointerException']
   ]]>
          </value>
        </property>
      </properties>
    </rule>


<!-- ============================================================
     JavaBean Rules
     ============================================================ -->


<!-- ============================================================
     java.lang.String Rules
     ============================================================ -->

<!--
    <rule name="AvoidDuplicateLiterals"
        message="The String literal {0} appears {1} times in this file; the first occurrence is on line {2}"
        class="net.sourceforge.pmd.rules.AvoidDuplicateLiteralsRule">
    <description>
Code containing duplicate String literals can usually be improved by declaring the String as a constant field.
    </description>
        <priority>3</priority>
   <properties>
    <property name="threshold" value="4"/>
   </properties>
    <example>
<![CDATA[
public class Foo {
 private void bar() {
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
    buz("Howdy");
 }
 private void buz(String x) {}
}
]]>
    </example>
  </rule>
-->


    <rule name="StringInstantiation"
        message="Avoid instantiating String objects; this is unnecessary."
        class="net.sourceforge.pmd.rules.XPathRule">
    <description>
    Avoid instantiating String objects; this is usually unnecessary.
    </description>
       <properties>
           <property name="xpath">
               <value>
                   <![CDATA[
    //AllocationExpression[ClassOrInterfaceType/@Image='String'][count(.//Expression) < 2][not(ArrayDimsAndInits)]
                    ]]>
               </value>
           </property>
       </properties>
       <priority>2</priority>

    <example>
<![CDATA[
public class Foo {
 private String bar = new String("bar"); // just do a String bar = "bar";
}
]]>
    </example>
    </rule>



   <rule name="StringToString"
        message="Avoid calling toString() on String objects; this is unnecessary"
        class="net.sourceforge.pmd.rules.strings.StringToStringRule"
        externalInfoUrl="http://pmd.sourceforge.net/rules/strings.html#StringToString">
    <description>
    Avoid calling toString() on String objects; this is unnecessary
    </description>
       <priority>3</priority>
    <example>
<![CDATA[
public class Foo {
 private String baz() {
  String bar = "howdy";
  return bar.toString();
 }
}
]]>
    </example>
    </rule>


<!-- ============================================================
     Code Size Rules
     ============================================================ -->


<!-- ============================================================
     Import Statement Rules
     ============================================================ -->

  <rule name="DuplicateImports"
        message="Avoid duplicate imports such as ''{0}''"
        class="net.sourceforge.pmd.rules.imports.DuplicateImportsRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/imports.html#DuplicateImports">
    <description>
    Avoid duplicate import statements.
    </description>
      <priority>4</priority>
    <example>
<![CDATA[
import java.lang.String;
import java.lang.*;
public class Foo {}
]]>
    </example>
    </rule>

  <rule name="DontImportJavaLang"
        message="Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3)."
        class="net.sourceforge.pmd.rules.XPathRule">
    <description>
    Avoid importing anything from the package 'java.lang'.  These classes are automatically imported (JLS 7.5.3).
    </description>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
//ImportDeclaration
 [starts-with(Name/@Image, 'java.lang')]
 [not(starts-with(Name/@Image, 'java.lang.ref'))]
 [not(starts-with(Name/@Image, 'java.lang.reflect'))]
 [not(starts-with(Name/@Image, 'java.lang.annotation'))]
 [not(starts-with(Name/@Image, 'java.lang.instrument'))]
 [not(starts-with(Name/@Image, 'java.lang.management'))]
                ]]>
              </value>
          </property>
       </properties>
      <priority>4</priority>

    <example>
<![CDATA[
// this is bad
import java.lang.String;
public class Foo {}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo {}
]]>
    </example>
    </rule>


<!-- ============================================================
     Clone Implementation Rules
     ============================================================ -->


<!-- ============================================================
     Jakarta Commons Logging Rules
     ============================================================ -->


<!-- ============================================================
     Naming Rules
     ============================================================ -->

  <rule name="ShortVariable"
        message="Avoid variables with short names.  Choose a name that reflects the purpose of the variable."
        class="net.sourceforge.pmd.rules.XPathRule">
    <description>
Detects when a field, local or parameter has a short name.
    </description>
      <properties>
          <property name="xpath" pluginname="true">
              <value>
                  <![CDATA[
    //VariableDeclaratorId[string-length(@Image) < 3]
     [not(ancestor::ForInit)]
     [not((ancestor::FormalParameter) and (ancestor::TryStatement))]
                  ]]>
              </value>
          </property>
      </properties>
      <priority>3</priority>
    <example>
<![CDATA[
public class Something {
  private int q = 15; // VIOLATION - Field

  public static void main( String as[] ) {  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local

    for (int i = 0; i < 10; i++) { // Not a Violation (inside FOR)
      r += q;
    }
  }
}
]]>
    </example>
  </rule>

  <rule name="ShortMethodName"
        message="Avoid using short method names.  Choose a name that reflects what the method does."
        class="net.sourceforge.pmd.rules.XPathRule">
     <description>
Detects when very short method names are used.
     </description>
      <priority>3</priority>
      <properties>
          <property name="xpath">
              <value>
                  <![CDATA[
    //MethodDeclarator[string-length(@Image) < 3]
                  ]]>
              </value>
          </property>
      </properties>
     <example>
<![CDATA[
public class ShortMethod {
  public void a( int i ) { // Violation
  }
}
]]>
     </example>
  </rule>


    <rule name="AbstractNaming"
          message="Abstract classes should be named 'AbstractXxx'"
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
  Abstract classes should be named 'AbstractXXX'.
       </description>
        <priority>3</priority>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
//ClassOrInterfaceDeclaration
 [@Abstract='true' and @Interface='false']
 [starts-with(@Image,'Abstract') = 0]
                    ]]>
                </value>
            </property>
        </properties>
       <example>
<![CDATA[
public abstract class Foo { // should be AbstractFoo
}
]]>
       </example>
    </rule>

    <rule name="SuspiciousHashcodeMethodName"
          message="The method name and return type are suspiciously close to hashCode()"
          class="net.sourceforge.pmd.rules.XPathRule"
          externalInfoUrl="http://pmd.sourceforge.net/rules/naming.html#SuspiciousHashcodeMethodName">
       <description>
The method name and return type are suspiciously close to hashCode(), which
may mean you are intending to override the hashCode() method.
       </description>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//MethodDeclaration
 [ResultType
  //PrimitiveType
   [@Image='int']
   [//MethodDeclarator
    [@Image='hashcode' or @Image='HashCode' or @Image='Hashcode']
    [not(FormalParameters/*)]]]
]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
       <example>
    <![CDATA[
public class Foo {
 public int hashcode() {
 // oops, this probably was supposed to be hashCode
 }
}
    ]]>
       </example>
     </rule>


    <rule name="SuspiciousConstantFieldName"
          message="The field name indicates a constants but its modifiers don't"
          class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       A field name is all in uppercase characters, which in sun's java naming 
       conventions indicate a constant. However, the field is not final.
       </description>
        <properties>
            <property name="xpath">
                <value>
<![CDATA[
//ClassOrInterfaceDeclaration[@Interface='false']
 /ClassOrInterfaceBody/ClassOrInterfaceBodyDeclaration/FieldDeclaration
  [@Final='false']
  [VariableDeclarator/VariableDeclaratorId[upper-case(@Image)=@Image]]
 ]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>
       <example>
    <![CDATA[
public class Foo {
	// this is bad, since someone could accidentally 
	// do PI = 2.71828; which is actualy e
	// final double PI = 3.16; is ok
	double PI = 3.16;
	
}
    ]]>
       </example>
     </rule>

    <rule
        name="SuspiciousEqualsMethodName"
        message="The method name and parameter number are suspiciously close to equals(Object)"
        class="net.sourceforge.pmd.rules.XPathRule">
        <description>
              The method name and parameter number are suspiciously close to
     equals(Object), which may mean you are trying (and failing) to override the equals(Object)
        method.
        </description>
        <properties>
            <property name="xpath">
                <value>
        <![CDATA[
//MethodDeclarator [
(
@Image = 'equals'
  and count(FormalParameters/*) = 1
  and not (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
   [@Image = 'Object' or @Image = 'java.lang.Object'])
)
or
@Image='equal'
 and count(FormalParameters/*) = 1
 and (FormalParameters/FormalParameter/Type/ReferenceType/ClassOrInterfaceType
  [@Image = 'Object' or @Image = 'java.lang.Object'])

]
        ]]>
                    </value>
                 </property>
              </properties>
        <priority>2</priority>
        <example>
        <![CDATA[
    public class Foo {
         public int equals(Object o) {
         // oops, this probably was supposed to be boolean equals
         }
         public boolean equals(String s) {
         // oops, this probably was supposed to be equals(Object)
         }
    }
        ]]>
        </example>
    </rule>

    <rule name="AvoidNonConstructorMethodsWithClassName"
          message="Method ''{0}'' is not a constructor but it can be confused with one"
          class="net.sourceforge.pmd.rules.AvoidNonConstructorMethodsWithClassName">
      <description>
      It is very easy to confuse methods with classname with constructors. It is preferrable
      to name these non-constructor methods in a different way.
      </description>
      <properties></properties>
        <priority>3</priority>

      <example>
<![CDATA[
public class Foo {
	public void Foo() {
		// not really a constructor...
	}
}
]]>
      </example>
    </rule>


<!-- ============================================================
     JUnit Rules
     ============================================================ -->

    <rule name="JUnitStaticSuite"
          message="You have a suite() method that is not both public and static, so JUnit won't call it to get your TestSuite.  Is that what you wanted to do?"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      The suite() method in a JUnit test needs to be both public and static.
      </description>
        <properties>
        <property name="xpath">
            <value>
                <![CDATA[
  //MethodDeclaration[not(@Static='true') or not(@Public='true')]
   [MethodDeclarator/@Image='suite']
   [MethodDeclarator/FormalParameters/@ParameterCount=0]
                ]]>
            </value>
        </property>
        </properties>
        <priority>3</priority>

      <example>
  <![CDATA[
  import junit.framework.*;
  public class Foo extends TestCase {
   public void suite() {} // oops, should be static
   private static void suite() {} // oops, should be public
  }
  ]]>
      </example>
      </rule>


  <rule name="JUnitSpelling"
        message="You may have misspelled or miscapitalized a JUnit framework method (setUp() or tearDown())"
        class="net.sourceforge.pmd.rules.XPathRule">
    <description>
    Some JUnit framework methods are easy to misspell.
    </description>
      <properties>
      <property name="xpath">
          <value>
              <![CDATA[
//MethodDeclarator[(not(@Image = 'setUp')
 and translate(@Image, 'SETuP', 'setUp') = 'setUp')
 or (not(@Image = 'tearDown')
 and translate(@Image, 'TEARdOWN', 'tearDown') = 'tearDown')]
 [FormalParameters[count(*) = 0]]
              ]]>
          </value>
      </property>
      </properties>
      <priority>3</priority>

    <example>
<![CDATA[
import junit.framework.*;
public class Foo extends TestCase {
 public void setup() {} // oops, should be setUp
 public void TearDown() {} // oops, should be tearDown
}
]]>
    </example>
    </rule>

    <rule name="UseAssertEqualsInsteadOfAssertTrue"
          message="user assertEquals(x, y) instead of assertTrue(x.equals(y))"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
          This rule detects JUnit assertions in object equality. These assertions
          should be made by more specific methods, like assertEquals.
      </description>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[

//PrimaryExpression[
    PrimaryPrefix/Name[@Image = 'assertTrue']
][
    PrimarySuffix/Arguments/ArgumentList/Expression/PrimaryExpression/PrimaryPrefix/Name
    [ends-with(@Image, '.equals')]
]

 ]]>
            </value>
        </property>
    </properties>
        <priority>3</priority>
      <example>
<![CDATA[
public class FooTest extends TestCase {
    void testCode() {
        Object a, b;
        assertTrue(a.equals(b)); // bad usage
        assertEquals(a, b); // good usage
    }
}
]]>
      </example>
    </rule>


    <rule name="UseAssertSameInsteadOfAssertTrue"
          message="user assertSame(x, y) instead of assertTrue(x==y)"
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
          This rule detects JUnit assertions in object references equality. These assertions
          should be made by more specific methods, like assertSame, assertNotSame.
      </description>
    <properties>
        <property name="xpath">
            <value>
                <![CDATA[

//PrimaryExpression [
    PrimaryPrefix/Name[@Image = 'assertTrue' or @Image = 'assertFalse']
]
[PrimarySuffix/Arguments/ArgumentList/Expression/EqualityExpression[
        @Image = '==' or  @Image = '!='
    ]
]

 ]]>
            </value>
        </property>
    </properties>
        <priority>3</priority>
      <example>
<![CDATA[
public class FooTest extends TestCase {
    void testCode() {
        Object a, b;
        assertTrue(a==b); // bad usage
        assertSame(a, b);  // good usage
    }
}
]]>
      </example>
    </rule>


<!-- ============================================================
     Java Logging Rules
     ============================================================ -->


<!-- ============================================================
     Braces Rules
     ============================================================ -->

   <rule name="IfStmtsMustUseBraces"
         message="Always use curly braces around the body of an 'if' statement.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability."
         class="net.sourceforge.pmd.rules.XPathRule">
     <description>
     Avoid using if statements without using curly braces
     </description>
       <properties>
           <property name="xpath">
               <value>
                   <![CDATA[
    //IfStatement[count(*) < 3][not(Statement/Block)]
                   ]]>
               </value>
           </property>
       </properties>
       <priority>3</priority>

     <example>
 <![CDATA[
 public class Foo {
   public void bar() {
     int x = 0;
     if (foo) x++;
   }
 }
 ]]>
     </example>
     </rule>

    <rule name="WhileLoopsMustUseBraces"
         message="Always use curly braces around the body of a 'while' loop.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      Avoid using 'while' statements without using curly braces
      </description>
        <properties>
            <property name="xpath">
                <value>
                    <![CDATA[
    //WhileStatement[not(Statement/Block)]
                    ]]>
                </value>
            </property>
        </properties>
        <priority>3</priority>

      <example>
  <![CDATA[
    public void doSomething() {
      while (true)
          x++;
    }
  ]]>
      </example>
    </rule>

      <rule name="IfElseStmtsMustUseBraces"
         message="Always use curly braces around the body of an 'if' statement and its 'else'.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability."
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       Avoid using if..else statements without using curly braces
       </description>
         <properties>
             <property name="xpath">
                 <value>
<![CDATA[
//Statement
 [parent::IfStatement[@Else='true']]
 [not(child::Block)]
 [not(child::IfStatement)]
 ]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>

       <example>
   <![CDATA[

     public void doSomething() {
       // this is OK
       if (foo) x++;

       // but this is not
       if (foo)
           x=x+1;
       else
           x=x-1;
     }
   ]]>
       </example>
     </rule>

     <rule name="ForLoopsMustUseBraces"
         message="Always use curly braces around the body of a 'for' loop.  Omitting them makes it easier to introduce bugs as the code is edited over time.  They also improve readability."
           class="net.sourceforge.pmd.rules.XPathRule">
       <description>
       Avoid using 'for' statements without using curly braces
       </description>
         <properties>
             <property name="xpath">
                 <value>
                     <![CDATA[
    //ForStatement[not(Statement/Block)]
                     ]]>
                 </value>
             </property>
         </properties>
         <priority>3</priority>

       <example>
   <![CDATA[
     public void foo() {
       for (int i=0; i<42;i++)
           foo();
     }
   ]]>
       </example>
     </rule>


<!-- ============================================================
     Custom VT Rules
     ============================================================ -->

    <rule name="JUnitTestsHaveAssertions"
          message="A test case method should use one or more 'assert...()' methods to check that the desired behavior is actually occurring."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      All JUnit test methods should contain at least one assertion.
      </description>
        <properties>
        <property name="xpath">
            <value>
                <![CDATA[
  //MethodDeclaration
[starts-with(MethodDeclarator/@Image, 'test')]
[not(descendant::StatementExpression/PrimaryExpression/PrimaryPrefix/Name
        [starts-with(@Image, 'assert') or contains(@Image,'.assert')
          or @Image = 'fail' or contains(@Image,'.fail')] )]
[ancestor::ClassOrInterfaceDeclaration[
    count( ExtendsList[
        ClassOrInterfaceType/@Image='TestCase'
        or ClassOrInterfaceType/@Image='junit.framework.TestCase']
    ) = 1
    ]]
                ]]>
            </value>
        </property>
        </properties>
        <priority>2</priority>

      <example>
  <![CDATA[
  import junit.framework.*;
  public class Foo extends TestCase {
   public void test1() {} // oops, no assertion!
  }
  ]]>
      </example>
      </rule>

    <rule name="JUnitConstantAssertion"
          message="This assertion uses only values known at compile time, so it cannot test any useful behavior exhibited by your code at run-time."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      All assertEquals() or assertTrue() assertions in JUnit test methods
      should contain one or more non-literal parameters.
      </description>
        <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//StatementExpression/PrimaryExpression[
  PrimaryPrefix/Name/@Image='assertTrue' or
  PrimaryPrefix/Name/@Image='assertEquals']
  [not(PrimarySuffix/Arguments/ArgumentList/descendant::PrimaryPrefix/Name)]
  [ancestor::ClassOrInterfaceDeclaration[
    count( ExtendsList[
        ClassOrInterfaceType/@Image='TestCase'
        or ClassOrInterfaceType/@Image='junit.framework.TestCase']
    ) = 1
    ]]
                ]]>
            </value>
        </property>
        </properties>
        <priority>2</priority>

      <example>
  <![CDATA[
  import junit.framework.*;
  public class Foo extends TestCase {
   public void test1() {
       assertTrue( true );    // oops, does not test anything useful!
       assertEquals( 0, 0 );  // oops, does not test anything useful!
   }
  }
  ]]>
      </example>
      </rule>

    <rule name="JUnitTestClassNeedsTestCase"
          message="This JUnit test class does not contain any actual tests."
          class="net.sourceforge.pmd.rules.XPathRule">
      <description>
      All JUnit test classes should contain a test method.
      </description>
        <properties>
        <property name="xpath">
            <value>
                <![CDATA[
//ClassOrInterfaceDeclaration[
    count( ExtendsList[
        ClassOrInterfaceType/@Image='TestCase'
        or ClassOrInterfaceType/@Image='junit.framework.TestCase']
    ) = 1
    ][
  not(descendant::MethodDeclaration[
    starts-with(MethodDeclarator/@Image, 'test')])]
                ]]>
            </value>
        </property>
        </properties>
        <priority>2</priority>

      <example>
  <![CDATA[
  import junit.framework.*;
  public class Foo extends TestCase {
           // oops, no test cases!
   }
  }
  ]]>
      </example>
      </rule>


</ruleset>
